package org.virtuslab.inkuire.plugin.translators

import org.jetbrains.dokka.DokkaConfiguration
import org.jetbrains.dokka.base.signatures.KotlinSignatureUtils.modifiers
import org.jetbrains.dokka.model.*
import org.jetbrains.dokka.pages.*
import org.virtuslab.inkuire.kotlin.model.AncestryGraph
import org.virtuslab.inkuire.kotlin.model.SDFunction
import org.virtuslab.inkuire.kotlin.model.STypeConstructor
import org.virtuslab.inkuire.kotlin.model.util.CustomGson
import org.virtuslab.inkuire.plugin.content.InkuireContentPage
import org.virtuslab.inkuire.plugin.transformers.DefaultDokkaToSerializableModelTransformer
import org.virtuslab.inkuire.plugin.transformers.DefaultDokkaToSerializableModelTransformer.toSerializable
import org.virtuslab.inkuire.plugin.transformers.anyAndNothingAppender
import org.virtuslab.inkuire.plugin.transformers.functionalTypesNormalizerTransformer
import org.virtuslab.inkuire.plugin.transformers.javaPrimitivesMapper
import org.virtuslab.inkuire.plugin.translators.InkuireDocumentableToPageTranslator.toFunctionsJson

object InkuireDocumentableToPageTranslator {

    fun invoke(module: DModule): List<PageNode> = module.packages.let { packages ->
        packages.flatMap {
            it.functions +
                it.properties.mapNotNull { it.getter } +
                it.classlikes.flatMap { classlike -> classlike.getFunctions() }
        }.javaPrimitivesMapper().functionalTypesNormalizerTransformer()
    }.let { functions ->
        module.sourceSets.flatMap { sourceSet ->
            with(DefaultDokkaToSerializableModelTransformer) {
                listOf(
                    InkuireContentPage(
                        name = "${sourceSet.sourceSetID.sourceSetName}/${module.name}.inkuire.fdb",
                        strategy = RenderingStrategy.Write(
                            functions.filter {
                                sourceSet in it.sourceSets && ExtraModifiers.KotlinOnlyModifiers.Override !in (it.modifiers()[sourceSet] ?: emptySet())
                            }.map { it.toSerializable(sourceSet) }.distinct() // That distinct removes copies of autogenerated/inherited functions from data classes/Any class
                                .toFunctionsJson()
                        )
                    ),
                    InkuireContentPage(
                        name = "${sourceSet.sourceSetID.sourceSetName}/${module.name}.inkuire.adb",
                        strategy = RenderingStrategy.Write(typesAncestryGraph(module, sourceSet).anyAndNothingAppender().toAncestryGraphJson())
                    )
                )
            }
        }
    }

    private fun typesAncestryGraph(documentable: Documentable, sourceSet: DokkaConfiguration.DokkaSourceSet): List<AncestryGraph> {
        return documentable.children.filter { sourceSet in it.sourceSets }.fold(emptyList<AncestryGraph>()) { acc, elem ->
            acc + typesAncestryGraph(elem, sourceSet)
        } + documentable.toAncestryEntry(sourceSet, documentable)
    }

    private fun Documentable.toAncestryEntry(sourceSet: DokkaConfiguration.DokkaSourceSet, parent: Documentable): List<AncestryGraph> = when (this) {
        is DClasslike ->
            if (this is WithSupertypes) {
                listOf(
                    AncestryGraph(
                        dri.toSerializable(), (STypeConstructor(dri.toSerializable(), getPossibleGenerics())),
                        (
                            supertypes[sourceSet]?.map { it.typeConstructor.toSerializable() }
                                ?: emptyList()
                            )
                    )
                )
            } else {
                listOf(AncestryGraph(dri.toSerializable(), (STypeConstructor(dri.toSerializable(), getPossibleGenerics())), emptyList()))
            }
        is DTypeAlias ->
            listOf(AncestryGraph(dri.toSerializable(), (STypeConstructor(dri.toSerializable(), getPossibleGenerics())), listOfNotNull(underlyingType[sourceSet]?.toSerializable())))
        else -> emptyList()
    } + if (this is WithGenerics)
        generics.flatMap { it.toAncestryEntry(sourceSet, this) }
    else emptyList()

    private fun Documentable.getPossibleGenerics() = if (this is WithGenerics) {
        this.generics.map {
            it.toSerializable().variantTypeParameter
        }
    } else {
        emptyList()
    }

    private fun DClasslike.getFunctions(): List<DFunction> = (
        functions +
            classlikes.flatMap { it.getFunctions() } +
            properties.mapNotNull { it.getter } + if (this is DClass) constructors else emptyList()
        ).map {
        it.copy(
            generics = if (this is WithGenerics) (it.generics + this.generics).distinctBy { it.name } else it.generics
        )
    }

    private fun List<SDFunction>.toFunctionsJson(): String = CustomGson.instance.toJson(this)
    private fun List<AncestryGraph>.toAncestryGraphJson(): String = CustomGson.instance.toJson(this)
}
